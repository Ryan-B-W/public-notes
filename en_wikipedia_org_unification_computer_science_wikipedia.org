:PROPERTIES:
:ID:       b13e7ada-ec71-4759-ac9d-ba6f8b46af51
:ROAM_REFS: https://en.wikipedia.org/wiki/Unification_(computer_science)
:END:
#+title: (en.wikipedia.org) Unification (computer science) - Wikipedia
#+filetags: :website:

#+begin_quote
  In [[https://en.wikipedia.org/wiki/Logic][logic]] and [[https://en.wikipedia.org/wiki/Computer_science][computer science]], specifically [[https://en.wikipedia.org/wiki/Automated_reasoning][automated reasoning]], *unification* is an algorithmic process of [[https://en.wikipedia.org/wiki/Solving_equations][solving equations]] between symbolic [[https://en.wikipedia.org/wiki/Expression_(mathematics)][expressions]], each of the form /Left-hand side = Right-hand side/.  For example, using /x/,/y/,/z/ as variables, and taking /f/ to be an [[https://en.wikipedia.org/wiki/Uninterpreted_function][uninterpreted function]], the [[https://en.wikipedia.org/wiki/Singleton_(mathematics)][singleton]] equation set { /f/(1,/y/) = /f/(/x/,2) } is a syntactic first-order unification problem that has the substitution { /x/ [[https://en.wikipedia.org/wiki/↦][↦]] 1, /y/ ↦ 2 } as its only solution.

  Conventions differ on what values variables may assume and which expressions are considered equivalent.  In first-order syntactic unification, variables range over [[https://en.wikipedia.org/wiki/First-order_terms][first-order terms]] and equivalence is syntactic.  This version of unification has a unique "best" answer and is used in [[https://en.wikipedia.org/wiki/Logic_programming][logic programming]] and programming language [[https://en.wikipedia.org/wiki/Type_system][type system]] implementation, especially in [[https://en.wikipedia.org/wiki/Hindley–Milner][Hindley--Milner]] based [[https://en.wikipedia.org/wiki/Type_inference][type inference]] algorithms.  In higher-order unification, possibly restricted to *higher-order pattern unification*, terms may include lambda expressions, and equivalence is up to beta-reduction.  This version is used in [[https://en.wikipedia.org/wiki/Proof_assistant][proof assistants]] and higher-order logic programming, for example [[https://en.wikipedia.org/wiki/Isabelle_(theorem_prover)][Isabelle]], [[https://en.wikipedia.org/wiki/Twelf][Twelf]], and [[https://en.wikipedia.org/wiki/LambdaProlog][lambdaProlog]].  Finally, in semantic unification or E-unification, equality is subject to background knowledge and variables range over a variety of domains.  This version is used in [[https://en.wikipedia.org/wiki/SMT_solver][SMT solvers]], [[https://en.wikipedia.org/wiki/Term_rewriting][term rewriting]] algorithms, and [[https://en.wikipedia.org/wiki/Cryptographic_protocol][cryptographic protocol]] analysis.
#+end_quote
