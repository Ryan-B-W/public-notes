:PROPERTIES:
:ID:       2b674c22-8ea8-4da1-b374-2aa2990e9293
:ROAM_REFS: https://sarabander.github.io/sicp/html/index.xhtml
:END:
#+title: (sarabander.github.io) Structure and Interpretation of Computer Programs, 2e: Top
#+filetags: :scheme:lisp:programming:computer_science:books:website:

Main node: [[id:69d3e2e7-62dc-414f-90ee-86f4b4abbcb0][(sarabander.github.io) Structure and Interpretation of Computer Programs, 2e]].
#+begin_quote
  * Structure and Interpretation of Computer Programs, Second Edition

  Unofficial Texinfo Format 2.andresraba6.6

  *Harold Abelson and Gerald Jay Sussman with Julie Sussman, foreword by Alan J. Perlis*
#+end_quote
* (sarabander.github.io) SICP, 2e: Chapter 1 Building Abstractions with Procedures
:PROPERTIES:
:ID:       d9bdefb7-f325-4605-9a5a-c965263e2390
:ROAM_REFS: https://sarabander.github.io/sicp/html/Chapter-1.xhtml
:END:
** (sarabander.github.io) SICP, 2e: 1.1 The Elements of Programming
:PROPERTIES:
:ID:       b85b9acb-443c-4d3f-842b-1f663c99ef18
:ROAM_REFS: https://sarabander.github.io/sicp/html/1_002e1.xhtml
:END:
** (sarabander.github.io) SICP, 2e: 1.2 Procedures and the Processes They Generate
:PROPERTIES:
:ID:       d4e8ce6b-05bb-4338-b3ff-1bb12c109dea
:ROAM_REFS: https://sarabander.github.io/sicp/html/1_002e2.xhtml
:END:
** (sarabander.github.io) SICP, 2e: 1.3 Formulating Abstractions with Higher-Order Procedures
:PROPERTIES:
:ID:       10ed2665-130f-4398-8efa-ce9795584da0
:ROAM_REFS: https://sarabander.github.io/sicp/html/1_002e3.xhtml
:END:
* (sarabander.github.io) SICP, 2e: Chapter 2 Building Abstractions with Data
:PROPERTIES:
:ID:       4e6b6934-89b2-4125-b046-9628e20427e8
:ROAM_REFS: https://sarabander.github.io/sicp/html/Chapter-2.xhtml
:END:
** (sarabander.github.io) SICP, 2e: 2.1 Introduction to Data Abstraction
:PROPERTIES:
:ID:       6d5c6805-fb40-49d9-9a91-93733bde2818
:ROAM_REFS: https://sarabander.github.io/sicp/html/2_002e1.xhtml
:END:
** (sarabander.github.io) SICP, 2e: 2.2 Hierarchical Data and the Closure Property
:PROPERTIES:
:ID:       183c1aa8-f3cb-4712-9a69-c218be056654
:ROAM_REFS: https://sarabander.github.io/sicp/html/2_002e2.xhtml
:END:
*** (sarabander.github.io) SICP, 2e: 2.2, Footnote 72
:PROPERTIES:
:ID:       2edf6633-4e65-4ebd-81c3-a842cb759479
:ROAM_REFS: https://sarabander.github.io/sicp/html/2_002e2.xhtml#FOOT72
:END:

#+begin_quote
  [[https://sarabander.github.io/sicp/html/2_002e2.xhtml#DOCF72][^{72}]] The use of the word “closure” here comes from abstract algebra, where a set of elements is said to be closed under an operation if applying the operation to elements in the set produces an element that is again an element of the set.  The Lisp community also (unfortunately) uses the word “closure” to describe a totally unrelated concept: A closure is an implementation technique for representing procedures with free variables.  We do not use the word “closure” in this second sense in this book.
#+end_quote
** (sarabander.github.io) SICP, 2e: 2.3 Symbolic Data
:PROPERTIES:
:ID:       e45e5e54-2625-4d00-9e48-0d1cb002d2e6
:ROAM_REFS: https://sarabander.github.io/sicp/html/2_002e3.xhtml
:END:
** (sarabander.github.io) SICP, 2e: 2.4 Multiple Representations for Abstract Data
:PROPERTIES:
:ID:       b66aedcd-6879-4a7f-856f-4de22a9a7bcd
:ROAM_REFS: https://sarabander.github.io/sicp/html/2_002e4.xhtml
:END:
** (sarabander.github.io) SICP, 2e: 2.5 Systems with Generic Operations
:PROPERTIES:
:ID:       597e2dfe-3c20-4137-b005-390b5d614509
:ROAM_REFS: https://sarabander.github.io/sicp/html/2_002e5.xhtml
:END:
*** (sarabander.github.io) SICP, 2e: 2.5, Footnote 118
:PROPERTIES:
:ID:       eba3acf1-4582-49c4-b2af-4b66ac11437f
:ROAM_REFS: https://sarabander.github.io/sicp/html/2_002e5.xhtml#FOOT118
:END:

#+begin_quote
  This statement, which also appears in the first edition of this book, is just as true now as it was when we wrote it twelve years ago.  Developing a useful, general framework for expressing the relations among different types of entities (what philosophers call “ontology”) seems intractably difficult.  The main difference between the confusion that existed ten years ago and the confusion that exists now is that now a variety of inadequate ontological theories have been embodied in a plethora of correspondingly inadequate programming languages.  For example, much of the complexity of object-oriented programming languages---and the subtle and confusing differences among contemporary object-oriented languages---centers on the treatment of generic operations on interrelated types.  Our own discussion of computational objects in [[https://sarabander.github.io/sicp/html/Chapter-3.xhtml#Chapter-3][Chapter 3]] avoids these issues entirely.  Readers familiar with object-oriented programming will notice that we have much to say in chapter 3 about local state, but we do not even mention “classes” or “inheritance.”  In fact, we suspect that these problems cannot be adequately addressed in terms of computer-language design alone, without also drawing on work in knowledge representation and automated reasoning.
#+end_quote
* (sarabander.github.io) SICP, 2e: Chapter 3 Modularity, Objects, and State
:PROPERTIES:
:ID:       5181afc7-8056-4a0b-9f8b-9e5c1908a0e5
:ROAM_REFS: https://sarabander.github.io/sicp/html/Chapter-3.xhtml
:END:
** (sarabander.github.io) SICP, 2e: 3.1 Assignment and Local State
:PROPERTIES:
:ID:       c4efd117-2a1c-4066-844a-c7b6aaa13ac8
:ROAM_REFS: https://sarabander.github.io/sicp/html/3_002e1.xhtml
:END:
** (sarabander.github.io) SICP, 2e: 3.2 The Environment Model of Evaluation
:PROPERTIES:
:ID:       45d86aec-1cbf-4562-b350-6787585091e7
:ROAM_REFS: https://sarabander.github.io/sicp/html/3_002e2.xhtml
:END:
** (sarabander.github.io) SICP, 2e: 3.3 Modeling with Mutable Data
:PROPERTIES:
:ID:       29b23078-07a0-470c-a8f9-ba522c99f0ff
:ROAM_REFS: https://sarabander.github.io/sicp/html/3_002e3.xhtml
:END:
*** (sarabander.github.io) SICP, 2e: 3.3, Footnote 148
:PROPERTIES:
:ID:       a28f0383-3559-47db-8823-b329b017c2f0
:ROAM_REFS: https://sarabander.github.io/sicp/html/3_002e3.xhtml#FOOT148
:END:

#+begin_quote
  The subtleties of dealing with sharing of mutable data objects reflect the underlying issues of “sameness” and “change” that were raised in [[https://sarabander.github.io/sicp/html/3_002e1.xhtml#g_t3_002e1_002e3][3.1.3]].  We mentioned there that admitting change to our language requires that a compound object must have an “identity” that is something different from the pieces from which it is composed.  In Lisp, we consider this “identity” to be the quality that is tested by =eq?=, i.e., by equality of pointers.  Since in most Lisp implementations a pointer is essentially a memory address, we are “solving the problem” of defining the identity of objects by stipulating that a data object “itself” is the information stored in some particular set of memory locations in the computer.  This suffices for simple Lisp programs, but is hardly a general way to resolve the issue of “sameness” in computational models.
#+end_quote
** (sarabander.github.io) SICP, 2e: 3.4 Concurrency: Time Is of the Essence
:PROPERTIES:
:ID:       3d0e4610-7589-43ae-9c35-ecac837c09fb
:ROAM_REFS: https://sarabander.github.io/sicp/html/3_002e4.xhtml
:END:
** (sarabander.github.io) SICP, 2e: 3.5 Streams
:PROPERTIES:
:ID:       54d70486-2673-4a0e-81a4-0e31bd047b13
:ROAM_REFS: https://sarabander.github.io/sicp/html/3_002e5.xhtml
:END:
*** (sarabander.github.io) SICP, 2e: 3.5, Footnote 186
:PROPERTIES:
:ID:       b0cc674c-8490-4af4-a228-cd41e051a100
:ROAM_REFS: https://sarabander.github.io/sicp/html/3_002e5.xhtml#FOOT186
:END:

#+begin_quote
  There are many possible implementations of streams other than the one described in this section.  Delayed evaluation, which is the key to making streams practical, was inherent in Algol 60's /call-by-name/ parameter-passing method.  The use of this mechanism to implement streams was first described by [[https://sarabander.github.io/sicp/html/References.xhtml#Landin-_00281965_0029][Landin (1965)]].  Delayed evaluation for streams was introduced into Lisp by [[https://sarabander.github.io/sicp/html/References.xhtml#Friedman-and-Wise-_00281976_0029][Friedman and Wise (1976)]].  In their implementation, =cons= always delays evaluating its arguments, so that lists automatically behave as streams.  The memoizing optimization is also known as /call-by-need/.  The Algol community would refer to our original delayed objects as /call-by-name thunks/ and to the optimized versions as /call-by-need thunks/.
#+end_quote
*** (sarabander.github.io) SICP, 2e: 3.5, Footnote 200
:PROPERTIES:
:ID:       f23ccb01-9834-4270-9157-e6892a892293
:ROAM_REFS: https://sarabander.github.io/sicp/html/3_002e5.xhtml#FOOT200
:END:

#+begin_quote
  This is a small reflection, in Lisp, of the difficulties that conventional strongly typed languages such as Pascal have in coping with higher-order procedures.  In such languages, the programmer must specify the data types of the arguments and the result of each procedure: number, logical value, sequence, and so on.  Consequently, we could not express an abstraction such as “map a given procedure =proc= over all the elements in a sequence” by a single higher-order procedure such as =stream-map=.  Rather, we would need a different mapping procedure for each different combination of argument and result data types that might be specified for a =proc=.  Maintaining a practical notion of “data type” in the presence of higher-order procedures raises many difficult issues.  One way of dealing with this problem is illustrated by the language ML ([[https://sarabander.github.io/sicp/html/References.xhtml#Gordon-et-al_002e-1979][Gordon et al. 1979]]), whose “polymorphic data types” include templates for higher-order transformations between data types.  Moreover, data types for most procedures in ML are never explicitly declared by the programmer.  Instead, ML includes a /type-inferencing/ mechanism that uses information in the environment to deduce the data types for newly defined procedures.
#+end_quote
*** (sarabander.github.io) SICP, 2e: 3.5, Footnote 204
:PROPERTIES:
:ID:       77a8ed9a-c63c-4f59-b1eb-71bdcf057070
:ROAM_REFS: https://sarabander.github.io/sicp/html/3_002e5.xhtml#FOOT204
:END:

#+begin_quote
  The object model approximates the world by dividing it into separate pieces.  The functional model does not modularize along object boundaries.  The object model is useful when the unshared state of the “objects” is much larger than the state that they share.  An example of a place where the object viewpoint fails is quantum mechanics, where thinking of things as individual particles leads to paradoxes and confusions.  Unifying the object view with the functional view may have little to do with programming, but rather with fundamental epistemological issues.
#+end_quote
* (sarabander.github.io) SICP, 2e: Chapter 4 Metalinguistic Abstraction
:PROPERTIES:
:ID:       f357dc09-7f5c-4617-b488-7e5581610a81
:ROAM_REFS: https://sarabander.github.io/sicp/html/Chapter-4.xhtml
:END:
** (sarabander.github.io) SICP, 2e: 4.1 The Metacircular Evaluator
:PROPERTIES:
:ID:       bf2fb2a1-46ab-4e61-9224-5e92d399cb97
:ROAM_REFS: https://sarabander.github.io/sicp/html/4_002e1.xhtml
:END:
*** (sarabander.github.io) SICP, 2e: 4.1, Footnote 213
:PROPERTIES:
:ID:       80f32e87-a766-47c0-b698-8597076a382f
:ROAM_REFS: https://sarabander.github.io/sicp/html/4_002e1.xhtml#FOOT213
:END:

#+begin_quote
  As mentioned in [[https://sarabander.github.io/sicp/html/2_002e3.xhtml#g_t2_002e3_002e1][2.3.1]], the evaluator sees a quoted expression as a list beginning with =quote=, even if the expression is typed with the quotation mark.  For example, the expression ='a= would be seen by the evaluator as =(quote a)=.  See [[https://sarabander.github.io/sicp/html/2_002e3.xhtml#Exercise-2_002e55][Exercise 2.55]].
#+end_quote
*** (sarabander.github.io) SICP, 2e: 4.1, Footnote 228
:PROPERTIES:
:ID:       cf030a97-abaa-4a87-abc0-6305374b5166
:ROAM_REFS: https://sarabander.github.io/sicp/html/4_002e1.xhtml#FOOT228
:END:

#+begin_quote
  Wanting programs to not depend on this evaluation mechanism is the reason for the “management is not responsible” remark in [[https://sarabander.github.io/sicp/html/1_002e1.xhtml#Footnote-28][Footnote 28]] of [[https://sarabander.github.io/sicp/html/Chapter-1.xhtml#Chapter-1][Chapter 1]].  By insisting that internal definitions come first and do not use each other while the definitions are being evaluated, the IEEE standard for Scheme leaves implementors some choice in the mechanism used to evaluate these definitions.  The choice of one evaluation rule rather than another here may seem like a small issue, affecting only the interpretation of “badly formed” programs.  However, we will see in [[https://sarabander.github.io/sicp/html/5_002e5.xhtml#g_t5_002e5_002e6][5.5.6]] that moving to a model of simultaneous scoping for internal definitions avoids some nasty difficulties that would otherwise arise in implementing a compiler.
#+end_quote
*** (sarabander.github.io) SICP, 2e: 4.1, Footnote 232
:PROPERTIES:
:ID:       8dcad8c9-1dd2-49b8-9ca7-97fe8a246529
:ROAM_REFS: https://sarabander.github.io/sicp/html/4_002e1.xhtml#FOOT232
:END:

#+begin_quote
  This technique is an integral part of the compilation process, which we shall discuss in [[https://sarabander.github.io/sicp/html/Chapter-5.xhtml#Chapter-5][Chapter 5]].  Jonathan Rees wrote a Scheme interpreter like this in about 1982 for the T project ([[https://sarabander.github.io/sicp/html/References.xhtml#Rees-and-Adams-1982][Rees and Adams 1982]]).  Marc [[https://sarabander.github.io/sicp/html/References.xhtml#Feeley-_00281986_0029][Feeley (1986)]] (see also [[https://sarabander.github.io/sicp/html/References.xhtml#Feeley-and-Lapalme-1987][Feeley and Lapalme 1987]]) independently invented this technique in his master's thesis.
#+end_quote
** (sarabander.github.io) SICP, 2e: 4.2 Variations on a Scheme — Lazy Evaluation
:PROPERTIES:
:ID:       b01f3776-c3ea-430a-8df3-723db559fa6b
:ROAM_REFS: https://sarabander.github.io/sicp/html/4_002e2.xhtml
:END:
*** (sarabander.github.io) SICP, 2e: 4.2, Footnote 238
:PROPERTIES:
:ID:       57b03469-0372-49ca-b0ff-853279cbda16
:ROAM_REFS: https://sarabander.github.io/sicp/html/4_002e2.xhtml#FOOT238
:END:

#+begin_quote
  The word /thunk/ was invented by an informal working group that was discussing the implementation of call-by-name in Algol 60. They observed that most of the analysis of (“thinking about”) the expression could be done at compile time; thus, at run time, the expression would already have been “thunk” about ([[https://sarabander.github.io/sicp/html/References.xhtml#Ingerman-et-al_002e-1960][Ingerman et al. 1960]]).
#+end_quote
*** (sarabander.github.io) SICP, 2e: 4.2, Footnote 239
:PROPERTIES:
:ID:       0d6b37b2-0188-495e-8df9-f7fbdff7cdf9
:ROAM_REFS: https://sarabander.github.io/sicp/html/4_002e2.xhtml#FOOT239
:END:

#+begin_quote
  This is analogous to the use of =force= on the delayed objects that were introduced in [[https://sarabander.github.io/sicp/html/Chapter-3.xhtml#Chapter-3][Chapter 3]] to represent streams.  The critical difference between what we are doing here and what we did in [[https://sarabander.github.io/sicp/html/Chapter-3.xhtml#Chapter-3][Chapter 3]] is that we are building delaying and forcing into the evaluator, and thus making this uniform and automatic throughout the language.
#+end_quote
*** (sarabander.github.io) SICP, 2e: 4.2, Footnote 240
:PROPERTIES:
:ID:       73a012e2-88e4-4c06-8e46-dfab714c2d0e
:ROAM_REFS: https://sarabander.github.io/sicp/html/4_002e2.xhtml#FOOT240
:END:

#+begin_quote
  Lazy evaluation combined with memoization is sometimes referred to as /call-by-need/ argument passing, in contrast to /call-by-name/ argument passing.  (Call-by-name, introduced in Algol 60, is similar to non-memoized lazy evaluation.)  As language designers, we can build our evaluator to memoize, not to memoize, or leave this an option for programmers ([[https://sarabander.github.io/sicp/html/4_002e2.xhtml#Exercise-4_002e31][Exercise 4.31]]).  As you might expect from [[https://sarabander.github.io/sicp/html/Chapter-3.xhtml#Chapter-3][Chapter 3]], these choices raise issues that become both subtle and confusing in the presence of assignments.  (See [[https://sarabander.github.io/sicp/html/4_002e2.xhtml#Exercise-4_002e27][Exercise 4.27]] and [[https://sarabander.github.io/sicp/html/4_002e2.xhtml#Exercise-4_002e29][Exercise 4.29]].)  An excellent article by [[https://sarabander.github.io/sicp/html/References.xhtml#Clinger-_00281982_0029][Clinger (1982)]] attempts to clarify the multiple dimensions of confusion that arise here.
#+end_quote
*** (sarabander.github.io) SICP, 2e: 4.2, Footnote 241
:PROPERTIES:
:ID:       ca6cd248-5759-4656-8511-6f2eca9460ee
:ROAM_REFS: https://sarabander.github.io/sicp/html/4_002e2.xhtml#FOOT241
:END:

#+begin_quote
  Notice that we also erase the =env= from the thunk once the expression's value has been computed.  This makes no difference in the values returned by the interpreter.  It does help save space, however, because removing the reference from the thunk to the =env= once it is no longer needed allows this structure to be /garbage-collected/ and its space recycled, as we will discuss in [[https://sarabander.github.io/sicp/html/5_002e3.xhtml#g_t5_002e3][5.3]].

  Similarly, we could have allowed unneeded environments in the memoized delayed objects of [[https://sarabander.github.io/sicp/html/3_002e5.xhtml#g_t3_002e5_002e1][3.5.1]] to be garbage-collected, by having =memo-proc= do something like =(set! proc '())= to discard the procedure =proc= (which includes the environment in which the =delay= was evaluated) after storing its value.
#+end_quote
** (sarabander.github.io) SICP, 2e: 4.3 Variations on a Scheme — Nondeterministic Computing
:PROPERTIES:
:ID:       da4c3b80-24fe-4817-8443-87a1ccee7910
:ROAM_REFS: https://sarabander.github.io/sicp/html/4_002e3.xhtml
:END:
** (sarabander.github.io) SICP, 2e: 4.4 Logic Programming
:PROPERTIES:
:ID:       dfb7cf86-1daa-4b28-9c43-1d8026b1a970
:ROAM_REFS: https://sarabander.github.io/sicp/html/4_002e4.xhtml
:END:
* (sarabander.github.io) SICP, 2e: Chapter 5 Computing with Register Machines
:PROPERTIES:
:ID:       172ddc04-d76f-4b00-ae7d-b74f48af5d16
:ROAM_REFS: https://sarabander.github.io/sicp/html/Chapter-5.xhtml
:END:
** (sarabander.github.io) SICP, 2e: 5.1 Designing Register Machines
:PROPERTIES:
:ID:       a179b468-af99-43b8-9372-f0921f9a55b0
:ROAM_REFS: https://sarabander.github.io/sicp/html/5_002e1.xhtml
:END:
** (sarabander.github.io) SICP, 2e: 5.2 A Register-Machine Simulator
:PROPERTIES:
:ID:       fa25c4ee-3b19-4cbb-89d4-ef50b05f01f2
:ROAM_REFS: https://sarabander.github.io/sicp/html/5_002e2.xhtml
:END:
*** (sarabander.github.io) SICP, 2e: 5.2, Footnote 289
:PROPERTIES:
:ID:       813fe83b-6aa1-46a8-a578-022e5ab8081a
:ROAM_REFS: https://sarabander.github.io/sicp/html/5_002e2.xhtml#FOOT289
:END:

#+begin_quote
  Using the =receive= procedure here is a way to get =extract-labels= to effectively return two values---=labels= and =insts=---without explicitly making a compound data structure to hold them.  An alternative implementation, which returns an explicit pair of values, is

  #+begin_src scheme
    (define (extract-labels text)
      (if (null? text)
          (cons '() '())
          (let ((result
                 (extract-labels (cdr text))))
            (let ((insts (car result))
                  (labels (cdr result)))
              (let ((next-inst (car text)))
                (if (symbol? next-inst)
                    (cons
                     insts
                     (cons
                      (make-label-entry
                       next-inst insts)
                      labels))
                    (cons
                     (cons
                      (make-instruction next-inst)
                      insts)
                     labels)))))))
  #+end_src

  which would be called by =assemble= as follows:

  #+begin_src scheme
    (define (assemble controller-text machine)
      (let ((result
             (extract-labels controller-text)))
        (let ((insts (car result))
              (labels (cdr result)))
          (update-insts! insts labels machine)
          insts)))
  #+end_src

  You can consider our use of =receive= as demonstrating an elegant way to return multiple values, or simply an excuse to show off a programming trick.  An argument like =receive= that is the next procedure to be invoked is called a “continuation.”  Recall that we also used continuations to implement the backtracking control structure in the =amb= evaluator in [[https://sarabander.github.io/sicp/html/4_002e3.xhtml#g_t4_002e3_002e3][4.3.3]].
#+end_quote
*** (sarabander.github.io) SICP, 2e: 5.1: Figure 5.11: A recursive factorial machine.
:PROPERTIES:
:ID:       494d72f3-4d9f-46d2-975a-b21bc543b599
:ROAM_REFS: https://sarabander.github.io/sicp/html/5_002e1.xhtml#Figure-5_002e11
:END:
** (sarabander.github.io) SICP, 2e: 5.3 Storage Allocation and Garbage Collection
:PROPERTIES:
:ID:       cf76bb72-62a0-4942-97df-4b70582e7c52
:ROAM_REFS: https://sarabander.github.io/sicp/html/5_002e3.xhtml
:END:
*** (sarabander.github.io) SICP, 2e: 5.3, Footnote 293
:PROPERTIES:
:ID:       6f27112a-5dca-4aa6-8970-fbdf008addd5
:ROAM_REFS: https://sarabander.github.io/sicp/html/5_002e3.xhtml#FOOT293
:END:

#+begin_quote
  Type information may be encoded in a variety of ways, depending on the details of the machine on which the Lisp system is to be implemented.  The execution efficiency of Lisp programs will be strongly dependent on how cleverly this choice is made, but it is difficult to formulate general design rules for good choices.  The most straightforward way to implement typed pointers is to allocate a fixed set of bits in each pointer to be a /type field/ that encodes the data type.  Important questions to be addressed in designing such a representation include the following: How many type bits are required?  How large must the vector indices be?  How efficiently can the primitive machine instructions be used to manipulate the type fields of pointers?  Machines that include special hardware for the efficient handling of type fields are said to have /tagged architectures/.
#+end_quote
*** (sarabander.github.io) SICP, 2e: 5.3, Footnote 295
:PROPERTIES:
:ID:       59be6eec-2cb1-48e6-8d53-4ef5fbb16ca4
:ROAM_REFS: https://sarabander.github.io/sicp/html/5_002e3.xhtml#FOOT295
:END:

#+begin_quote
  There are other ways of finding free storage.  For example, we could link together all the unused pairs into a /free list/.  Our free locations are consecutive (and hence can be accessed by incrementing a pointer) because we are using a compacting garbage collector, as we will see in [[https://sarabander.github.io/sicp/html/5_002e3.xhtml#g_t5_002e3_002e2][5.3.2]].
#+end_quote
*** (sarabander.github.io) SICP, 2e: 5.3, Footnote 300
:PROPERTIES:
:ID:       7c56e2f1-9200-438b-aee9-4f30f7c518ff
:ROAM_REFS: https://sarabander.github.io/sicp/html/5_002e3.xhtml#FOOT300
:END:

#+begin_quote
  This idea was invented and first implemented by Minsky, as part of the implementation of Lisp for the PDP-1 at the MIT Research Laboratory of Electronics.  It was further developed by [[https://sarabander.github.io/sicp/html/References.xhtml#Fenichel-and-Yochelson-_00281969_0029][Fenichel and Yochelson (1969)]] for use in the Lisp implementation for the Multics time-sharing system.  Later, [[https://sarabander.github.io/sicp/html/References.xhtml#Baker-_00281978_0029][Baker (1978)]] developed a “real-time” version of the method, which does not require the computation to stop during garbage collection.  Baker's idea was extended by Hewitt, Lieberman, and Moon (see [[https://sarabander.github.io/sicp/html/References.xhtml#Lieberman-and-Hewitt-1983][Lieberman and Hewitt 1983]]) to take advantage of the fact that some structure is more volatile and other structure is more permanent.

  An alternative commonly used garbage-collection technique is the /mark-sweep/ method.  This consists of tracing all the structure accessible from the machine registers and marking each pair we reach.  We then scan all of memory, and any location that is unmarked is “swept up” as garbage and made available for reuse.  A full discussion of the mark-sweep method can be found in [[https://sarabander.github.io/sicp/html/References.xhtml#Allen-1978][Allen 1978]].

  The Minsky-Fenichel-Yochelson algorithm is the dominant algorithm in use for large-memory systems because it examines only the useful part of memory.  This is in contrast to mark-sweep, in which the sweep phase must check all of memory.  A second advantage of stop-and-copy is that it is a /compacting/ garbage collector.  That is, at the end of the garbage-collection phase the useful data will have been moved to consecutive memory locations, with all garbage pairs compressed out.  This can be an extremely important performance consideration in machines with virtual memory, in which accesses to widely separated memory addresses may require extra paging operations.
#+end_quote
** (sarabander.github.io) SICP, 2e: 5.4 The Explicit-Control Evaluator
:PROPERTIES:
:ID:       1c11db84-5c96-4df9-b4b9-79de9b0e42e1
:ROAM_REFS: https://sarabander.github.io/sicp/html/5_002e4.xhtml
:END:
*** (sarabander.github.io) SICP, 2e: 5.4, Footnote 305
:PROPERTIES:
:ID:       61e391c5-a7ac-425c-b4b3-656034f08a1e
:ROAM_REFS: https://sarabander.github.io/sicp/html/5_002e4.xhtml#FOOT305
:END:

#+begin_quote
  In our controller, the dispatch is written as a sequence of =test= and =branch= instructions.  Alternatively, it could have been written in a data-directed style (and in a real system it probably would have been) to avoid the need to perform sequential tests and to facilitate the definition of new expression types.  A machine designed to run Lisp would probably include a =dispatch-on-type= instruction that would efficiently execute such data-directed dispatches.
#+end_quote
*** (sarabander.github.io) SICP, 2e: 5.4, Footnote 306
:PROPERTIES:
:ID:       e332adfd-dd0f-46b6-8e5d-6375c41cc59c
:ROAM_REFS: https://sarabander.github.io/sicp/html/5_002e4.xhtml#FOOT306
:END:

#+begin_quote
  This is an important but subtle point in translating algorithms from a procedural language, such as Lisp, to a register-machine language.  As an alternative to saving only what is needed, we could save all the registers (except =val=) before each recursive call.  This is called a /framed-stack/ discipline.  This would work but might save more registers than necessary; this could be an important consideration in a system where stack operations are expensive.  Saving registers whose contents will not be needed later may also hold onto useless data that could otherwise be garbage-collected, freeing space to be reused.
#+end_quote
*** (sarabander.github.io) SICP, 2e: 5.4, Footnote 308
:PROPERTIES:
:ID:       c8e8d519-ddb9-40ee-aa13-6527475c0665
:ROAM_REFS: https://sarabander.github.io/sicp/html/5_002e4.xhtml#FOOT308
:END:

#+begin_quote
  The optimization of treating the last operand specially is known as /evlis tail recursion/ (see [[https://sarabander.github.io/sicp/html/References.xhtml#Wand-1980][Wand 1980]]).  We could be somewhat more efficient in the argument evaluation loop if we made evaluation of the first operand a special case too.  This would permit us to postpone initializing =argl= until after evaluating the first operand, so as to avoid saving =argl= in this case.  The compiler in [[https://sarabander.github.io/sicp/html/5_002e5.xhtml#g_t5_002e5][5.5]] performs this optimization.  (Compare the =construct-arglist= procedure of [[https://sarabander.github.io/sicp/html/5_002e5.xhtml#g_t5_002e5_002e3][5.5.3]].)
#+end_quote
*** (sarabander.github.io) SICP, 2e: 5.4, Footnote 309
:PROPERTIES:
:ID:       3e3d1128-f6b6-4d35-b1b4-cb632f084a2b
:ROAM_REFS: https://sarabander.github.io/sicp/html/5_002e4.xhtml#FOOT309
:END:

#+begin_quote
  The order of operand evaluation in the metacircular evaluator is determined by the order of evaluation of the arguments to =cons= in the procedure =list-of-values= of [[https://sarabander.github.io/sicp/html/4_002e1.xhtml#g_t4_002e1_002e1][4.1.1]] (see [[https://sarabander.github.io/sicp/html/4_002e1.xhtml#Exercise-4_002e1][Exercise 4.1]]).
#+end_quote
** (sarabander.github.io) SICP, 2e: 5.5 Compilation
:PROPERTIES:
:ID:       eecde4f8-9302-4eb7-a09b-6ee1217b3414
:ROAM_REFS: https://sarabander.github.io/sicp/html/5_002e5.xhtml
:END:
*** (sarabander.github.io) SICP, 2e: 5.5, Footnote 321
:PROPERTIES:
:ID:       8ac67c01-5578-4ca2-bf86-df0b0210667b
:ROAM_REFS: https://sarabander.github.io/sicp/html/5_002e5.xhtml#FOOT321
:END:

#+begin_quote
  This procedure uses a feature of Lisp called /backquote/ (or /quasiquote/) that is handy for constructing lists.  Preceding a list with a backquote symbol is much like quoting it, except that anything in the list that is flagged with a comma is evaluated.

  For example, if the value of =linkage= is the symbol =branch25=, then the expression

  #+begin_src scheme
    `((goto (label ,linkage)))
  #+end_src

  evaluates to the list

  #+begin_src scheme
    ((goto (label branch25)))
  #+end_src

  Similarly, if the value of =x= is the list =(a b c)=, then

  #+begin_src scheme
    `(1 2 ,(car x))
  #+end_src

  evaluates to the list

  #+begin_src scheme
    (1 2 a)
  #+end_src
#+end_quote
* (sarabander.github.io) SICP, 2e: References
:PROPERTIES:
:ID:       54ca1727-d685-4343-a0e3-3f07a815ea58
:ROAM_REFS: https://sarabander.github.io/sicp/html/References.xhtml
:END:
** (sarabander.github.io) SICP, 2e: References, Batali et al. 1982
:PROPERTIES:
:ID:       c22ddfdc-da44-448b-b370-959f9e309809
:ROAM_REFS: https://sarabander.github.io/sicp/html/References.xhtml#Batali-et-al_002e-1982
:END:

#+begin_quote
  Batali, John, Neil Mayle, Howard Shrobe, Gerald Jay Sussman, and Daniel Weise.  1982.  The Scheme-81 architecture---System and chip.  In Proceedings of the MIT Conference on Advanced Research in VLSI, edited by Paul Penfield, Jr. Dedham, MA: Artech House.
#+end_quote
** (sarabander.github.io) SICP, 2e: References, Wand 1980
:PROPERTIES:
:ID:       120c4907-1fda-45e5-b10a-35d9e5728eaf
:ROAM_REFS: https://sarabander.github.io/sicp/html/References.xhtml#Wand-1980
:END:

#+begin_quote
  Wand, Mitchell. 1980. Continuation-based program transformation strategies. Journal of the ACM 27(1): 164-180. [[http://www.diku.dk/OLD/undervisning/2005e/224/papers/Wand80.pdf][--›]]
#+end_quote
* (sarabander.github.io) SICP, 2e: Term Index
:PROPERTIES:
:ID:       5eac4aa2-ab1e-44ae-bfd8-498e800d9a14
:ROAM_REFS: https://sarabander.github.io/sicp/html/Term-Index.xhtml
:END:

#+begin_quote
  ** Term Index

  : Any inaccuracies in this index may be explained by the fact that it has been prepared with the help of a computer.
  :
  : ---Donald E. Knuth, Fundamental Algorithms\\
  : (Volume 1 of The Art of Computer Programming)
#+end_quote
