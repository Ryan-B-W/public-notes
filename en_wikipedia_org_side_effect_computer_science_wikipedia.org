:PROPERTIES:
:ID:       49444189-1d98-43b7-b64c-2c31466c4734
:ROAM_REFS: https://en.wikipedia.org/wiki/Side_effect_(computer_science)
:END:
#+title: (en.wikipedia.org) Side effect (computer science) - Wikipedia
#+filetags: :website:

#+begin_quote
  In [[https://en.wikipedia.org/wiki/Computer_science][computer science]], an operation, [[https://en.wikipedia.org/wiki/Subroutine][function]] or [[https://en.wikipedia.org/wiki/Expression_(programming)][expression]] is said to have a *side effect* if it has any observable effect other than its primary effect of reading the value of its arguments and returning a value to the invoker of the operation.  Example side effects include modifying a [[https://en.wikipedia.org/wiki/Non-local_variable][non-local variable]], a [[https://en.wikipedia.org/wiki/Static_local_variable][static local variable]] or a mutable argument [[https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_reference][passed by reference]]; raising errors or exceptions; performing [[https://en.wikipedia.org/wiki/I/O][I/O]]; or calling other functions with side-effects.  In the presence of side effects, a program's behaviour may depend on history; that is, the order of evaluation matters.  Understanding and debugging a function with side effects requires knowledge about the context and its possible histories.  Side effects play an important role in the design and analysis of [[https://en.wikipedia.org/wiki/Programming_language][programming languages]].  The degree to which side effects are used depends on the programming paradigm.  For example, [[https://en.wikipedia.org/wiki/Imperative_programming][imperative programming]] is commonly used to produce side effects, to update a system's state.  By contrast, [[https://en.wikipedia.org/wiki/Declarative_programming][declarative programming]] is commonly used to report on the state of system, without side effects.

  [[https://en.wikipedia.org/wiki/Functional_programming][Functional programming]] aims to minimize or eliminate side effects.  The lack of side effects makes it easier to do [[https://en.wikipedia.org/wiki/Formal_verification][formal verification]] of a program.  The functional language [[https://en.wikipedia.org/wiki/Haskell_(programming_language)][Haskell]] eliminates side effects such as [[https://en.wikipedia.org/wiki/Input/output][I/O]] and other stateful computations by replacing them with [[https://en.wikipedia.org/wiki/Monad_(functional_programming)][monadic]] actions.  Functional languages such as [[https://en.wikipedia.org/wiki/Standard_ML][Standard ML]], [[https://en.wikipedia.org/wiki/Scheme_(programming_language)][Scheme]] and [[https://en.wikipedia.org/wiki/Scala_(programming_language)][Scala]] do not restrict side effects, but it is customary for programmers to avoid them.

  [[https://en.wikipedia.org/wiki/Effect_system][Effect systems]] extend types to keep track of effects, permitting concise notation for functions with effects, while maintaining information about the extent and nature of side effects.  In particular, functions without effects correspond to pure functions.

  [[https://en.wikipedia.org/wiki/Assembly_language][Assembly language]] programmers must be aware of /hidden/ side effects---instructions that modify parts of the processor state which are not mentioned in the instruction's mnemonic.  A classic example of a hidden side effect is an arithmetic instruction that implicitly modifies [[https://en.wikipedia.org/wiki/Status_register][condition codes]] (a hidden side effect) while it explicitly modifies a [[https://en.wikipedia.org/wiki/Processor_register][register]] (the intended effect).  One potential drawback of an [[https://en.wikipedia.org/wiki/Instruction_set][instruction set]] with hidden side effects is that, if many instructions have side effects on a single piece of state, like condition codes, then the logic required to update that state sequentially may become a performance bottleneck.  The problem is particularly acute on some processors designed with [[https://en.wikipedia.org/wiki/Instruction_pipeline][pipelining]] (since 1990) or with [[https://en.wikipedia.org/wiki/Out-of-order_execution][out-of-order execution]].  Such a processor may require additional control circuitry to detect hidden side effects and stall the pipeline if the next instruction depends on the results of those effects.
#+end_quote
