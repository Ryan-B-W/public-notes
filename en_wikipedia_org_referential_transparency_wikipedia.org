:PROPERTIES:
:ID:       712f13d2-7769-4807-864b-458f96125f6e
:ROAM_REFS: https://en.wikipedia.org/wiki/Referential_transparency
:END:
#+title: (en.wikipedia.org) Referential transparency - Wikipedia
#+filetags: :website:

#+begin_quote
  In [[https://en.wikipedia.org/wiki/Analytic_philosophy][analytic philosophy]] and [[https://en.wikipedia.org/wiki/Computer_science][computer science]], *referential transparency* and *referential opacity* are properties of linguistic constructions, and by extension of languages.  A linguistic construction is called /referentially transparent/ when for any expression built from it, [[https://en.wikipedia.org/wiki/Rewriting][replacing]] a subexpression with another one that [[https://en.wikipedia.org/wiki/Denotation][denotes]] the same value does not change the value of the expression.  Otherwise, it is called /referentially opaque/.  Each expression built from a referentially opaque linguistic construction states something about a subexpression, whereas each expression built from a referentially transparent linguistic construction states something not about a subexpression, meaning that the subexpressions are ‘transparent' to the expression, acting merely as ‘references' to something else.  For example, the linguistic construction ‘_ was wise' is referentially transparent (e.g., /Socrates was wise/ is equivalent to /The founder of Western philosophy was wise/) but ‘_ said _' is referentially opaque (e.g., /Xenophon said ‘Socrates was wise'/ is not equivalent to /Xenophon said ‘The founder of Western philosophy was wise'/).

  Referential transparency, in programming languages, depends on semantic equivalences among denotations of expressions, or on [[https://en.wikipedia.org/wiki/Contextual_equivalence][contextual equivalence]] of expressions themselves.  That is, referential transparency depends on the semantics of the language.  So, both [[https://en.wikipedia.org/wiki/Declarative_language][declarative languages]] and [[https://en.wikipedia.org/wiki/Imperative_language][imperative languages]] can have referentially transparent positions, referentially opaque positions, or (usually) both, according to the semantics they are given.

  The importance of referentially transparent positions is that they allow the [[https://en.wikipedia.org/wiki/Programmer][programmer]] and the [[https://en.wikipedia.org/wiki/Compiler][compiler]] to reason about program behavior as a [[https://en.wikipedia.org/wiki/Rewrite_system][rewrite system]] at those positions.  This can help in proving [[https://en.wikipedia.org/wiki/Correctness_(computer_science)][correctness]], simplifying an [[https://en.wikipedia.org/wiki/Algorithm][algorithm]], assisting in modifying code without breaking it, or [[https://en.wikipedia.org/wiki/Optimization_(computer_science)][optimizing]] code by means of [[https://en.wikipedia.org/wiki/Memoization][memoization]], [[https://en.wikipedia.org/wiki/Common_subexpression_elimination][common subexpression elimination]], [[https://en.wikipedia.org/wiki/Lazy_evaluation][lazy evaluation]], or [[https://en.wikipedia.org/wiki/Parallelization][parallelization]].
#+end_quote
